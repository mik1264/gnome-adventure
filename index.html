<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Bomb Field Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #667eea 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @media (max-width: 1024px) {
            body {
                padding: 10px;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 0 60px rgba(102, 126, 234, 0.3);
            overflow: hidden;
            animation: containerFloat 6s ease-in-out infinite;
        }

        @keyframes containerFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 15px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 0.95em;
            opacity: 0.9;
        }

        @media (max-width: 1024px) {
            .header {
                padding: 6px 10px;
            }

            .header h1 {
                font-size: 1.1em;
                margin-bottom: 0;
            }

            .header p {
                display: none; /* Hide subtitle on tablets to save space */
            }
        }

        .controls {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        @media (max-width: 1024px) {
            .controls {
                padding: 6px 8px;
                display: flex;
                gap: 4px;
                align-items: center;
                flex-wrap: nowrap;
            }
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: flex-start;
            margin-bottom: 0;
            flex: 1;
        }

        @media (max-width: 1024px) {
            .control-group {
                gap: 3px;
                margin-bottom: 0;
                flex-wrap: nowrap;
                align-items: center;
                justify-content: flex-start;
                flex: 1;
            }
        }

        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        @media (max-width: 1024px) {
            .control-item {
                gap: 1px;
                flex-shrink: 0;
            }
        }

        .control-item label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
        }

        @media (max-width: 1024px) {
            .control-item label {
                font-size: 0.65em;
                white-space: nowrap;
            }
        }

        .control-item input {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            width: 100px;
            text-align: center;
            transition: border-color 0.3s;
        }

        @media (max-width: 1024px) {
            .control-item input {
                padding: 4px;
                font-size: 0.75em;
                width: 50px;
            }
        }

        .control-item input:focus {
            outline: none;
            border-color: #007bff;
        }

        .control-item input[type="range"] {
            width: 150px;
            padding: 0;
            cursor: pointer;
        }

        @media (max-width: 1024px) {
            .control-item input[type="range"] {
                width: 80px;
            }
        }

        .control-item select {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            width: 150px;
            cursor: pointer;
            transition: border-color 0.3s;
            background: white;
        }

        @media (max-width: 1024px) {
            .control-item select {
                padding: 4px;
                font-size: 0.75em;
                width: 90px;
            }
        }

        .control-item select:focus {
            outline: none;
            border-color: #007bff;
        }

        #speedValue {
            font-weight: bold;
            color: #007bff;
        }

        .help-section {
            margin-top: 0;
            border-top: none;
            padding-top: 0;
            flex-shrink: 0;
        }

        @media (max-width: 1024px) {
            .help-section {
                margin-top: 0;
                padding-top: 0;
                border-top: none;
                flex-shrink: 0;
            }
        }

        .help-header {
            font-weight: 600;
            font-size: 0.9em;
            color: #007bff;
            cursor: pointer;
            user-select: none;
            padding: 8px 10px;
            background: transparent;
            border-radius: 8px;
            transition: background 0.3s;
            text-decoration: underline;
        }

        @media (max-width: 1024px) {
            .help-header {
                font-size: 0.65em;
                padding: 4px 6px;
                background: transparent;
                color: #007bff;
                cursor: pointer;
                text-decoration: underline;
            }
        }

        .help-header:hover {
            background: #e9ecef;
        }

        #help-toggle {
            display: none;
        }

        .help-content {
            display: none;
        }

        .help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .help-modal.active {
            display: flex;
        }

        .help-modal-content {
            background: white;
            border-radius: 15px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .help-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            cursor: pointer;
            background: none;
            border: none;
            color: #6c757d;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal-close:hover {
            color: #000;
        }

        .help-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }

        @media (max-width: 1024px) {
            .help-grid {
                grid-template-columns: 1fr;
                gap: 6px;
                margin-bottom: 8px;
            }
        }

        .help-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        @media (max-width: 1024px) {
            .help-item {
                padding: 6px 8px;
                gap: 6px;
            }
        }

        .help-icon {
            font-size: 1.5em;
            flex-shrink: 0;
        }

        @media (max-width: 1024px) {
            .help-icon {
                font-size: 1.2em;
            }
        }

        .help-text {
            font-size: 0.9em;
            color: #495057;
            line-height: 1.4;
        }

        @media (max-width: 1024px) {
            .help-text {
                font-size: 0.75em;
                line-height: 1.3;
            }
        }

        .help-tips {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        @media (max-width: 1024px) {
            .help-tips {
                padding: 8px;
                margin-top: 8px;
                border-radius: 6px;
            }
        }

        .help-tips strong {
            color: #856404;
            display: block;
            margin-bottom: 8px;
        }

        @media (max-width: 1024px) {
            .help-tips strong {
                font-size: 0.8em;
                margin-bottom: 4px;
            }
        }

        .help-tips ul {
            margin: 0;
            padding-left: 20px;
            color: #856404;
        }

        @media (max-width: 1024px) {
            .help-tips ul {
                padding-left: 15px;
                font-size: 0.75em;
            }
        }

        .help-tips li {
            margin: 5px 0;
        }

        @media (max-width: 1024px) {
            .help-tips li {
                margin: 3px 0;
            }
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
            flex-shrink: 0;
        }

        @media (max-width: 1024px) {
            .button-group {
                gap: 3px;
                flex-direction: row;
                flex-shrink: 0;
            }
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @media (max-width: 1024px) {
            .btn {
                padding: 4px 8px;
                font-size: 0.65em;
                letter-spacing: 0.3px;
            }
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-primary:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.5);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            box-shadow: 0 2px 5px rgba(108, 117, 125, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn-secondary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn-secondary:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(108, 117, 125, 0.5);
        }

        .results {
            padding: 15px;
        }

        @media (max-width: 1024px) {
            .results {
                padding: 8px 10px;
            }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 12px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        @media (max-width: 1024px) {
            .stats {
                margin-bottom: 8px;
                padding: 6px 4px;
                flex-wrap: wrap;
                gap: 4px;
            }
        }

        .stat-item {
            text-align: center;
        }

        @media (max-width: 1024px) {
            .stat-item {
                flex: 1 1 auto;
                min-width: 55px;
            }
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #007bff;
            text-shadow: 0 1px 2px rgba(0, 123, 255, 0.2);
            transition: transform 0.2s, text-shadow 0.2s;
        }

        .stat-item:hover .stat-value {
            transform: scale(1.1);
            text-shadow: 0 2px 4px rgba(0, 123, 255, 0.4);
        }

        @media (max-width: 1024px) {
            .stat-value {
                font-size: 0.95em;
            }
        }

        .stat-label {
            font-size: 0.75em;
            color: #6c757d;
            margin-top: 3px;
        }

        @media (max-width: 1024px) {
            .stat-label {
                font-size: 0.6em;
                margin-top: 1px;
            }
        }

        .field-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }

        .field-display {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1), 0 0 30px rgba(102, 126, 234, 0.1);
            min-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        @media (max-width: 1024px) {
            .field-display {
                padding: 6px;
                border-radius: 6px;
            }
        }

        .field-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1em;
            font-weight: 600;
            color: #495057;
        }

        @media (max-width: 1024px) {
            .field-title {
                margin-bottom: 4px;
                font-size: 0.85em;
            }
        }

        .field-grid {
            display: grid;
            gap: 2px;
            background: #dee2e6;
            border-radius: 8px;
            padding: 10px;
            margin: 0 auto;
            max-width: 90vw;
            box-sizing: border-box;
        }

        @media (max-width: 1024px) {
            .field-grid {
                padding: 5px;
                gap: 1px;
            }
        }

        .field-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
            border-radius: 3px;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s;
            min-width: 0;
            min-height: 0;
            box-sizing: border-box;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .field-cell:hover {
            transform: scale(1.15) translateZ(10px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .cell-empty {
            background: #f8f9fa;
            color: #6c757d;
        }

        .cell-hidden {
            background: linear-gradient(135deg, #c0c0c0 0%, #909090 100%);
            color: #808080;
            font-weight: bold;
            font-size: 1.2em;
            animation: hiddenMystery 3s ease-in-out infinite;
        }

        @keyframes hiddenMystery {
            0%, 100% {
                background: linear-gradient(135deg, #c0c0c0 0%, #909090 100%);
            }
            50% {
                background: linear-gradient(135deg, #d0d0d0 0%, #a0a0a0 100%);
            }
        }

        .cell-bomb {
            background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
            color: white;
            animation: bombPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        @keyframes bombPulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(201, 42, 42, 0.8);
            }
        }

        .cell-flower {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: white;
            animation: flowerShimmer 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.6);
        }

        @keyframes flowerShimmer {
            0%, 100% {
                filter: brightness(1) saturate(1);
                transform: scale(1);
            }
            50% {
                filter: brightness(1.2) saturate(1.3);
                transform: scale(1.05);
            }
        }

        .cell-phoenix-flower {
            background: linear-gradient(135deg, #ff6b00 0%, #ff0000 100%);
            color: white;
            animation: phoenixGlow 1s ease-in-out infinite alternate;
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.6);
        }

        .cell-ghost-trail {
            background: linear-gradient(135deg, rgba(144, 238, 144, 0.6) 0%, rgba(102, 187, 106, 0.4) 100%);
            position: relative;
            animation: ghostFade 2s ease-in-out infinite;
        }

        .cell-ghost-trail::after {
            content: '👻';
            font-size: 0.7em;
            animation: ghostFloat 2s ease-in-out infinite;
        }

        @keyframes ghostFade {
            0%, 100% {
                filter: brightness(1);
            }
            50% {
                filter: brightness(1.2);
            }
        }

        @keyframes ghostFloat {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-2px);
            }
        }

        .cell-bomb-exploding {
            background: #ff0000;
            animation: bombExplode 0.5s ease-out;
        }

        .cell-gnome {
            background: linear-gradient(135deg, #90EE90 0%, #66BB6A 100%);
            color: #2e7d32;
            animation: gnomeWalk 0.5s ease-in-out infinite alternate;
            position: relative;
            box-shadow: 0 0 20px rgba(144, 238, 144, 0.6), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .cell-gnome.invincible {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            animation: invincibleShield 0.5s ease-in-out infinite alternate;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            position: relative;
        }

        .cell-gnome.invincible::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 400% 400%;
            border-radius: 5px;
            z-index: -1;
            animation: rainbowShield 3s ease infinite;
            opacity: 0.6;
        }

        @keyframes rainbowShield {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .cell-gnome.rewinding {
            background: #00d4ff;
            animation: rewindEffect 0.5s ease-in-out;
        }

        .cell-gnome.collecting {
            background: #FFD700;
            animation: gnomeCollect 0.3s ease-in-out;
            position: relative;
        }

        .cell-gnome.collecting::before,
        .cell-gnome.collecting::after {
            content: '✨';
            position: absolute;
            font-size: 1.5em;
            animation: sparkleFloat 0.6s ease-out forwards;
            pointer-events: none;
        }

        .cell-gnome.collecting::before {
            top: -10%;
            left: -10%;
            animation-delay: 0s;
        }

        .cell-gnome.collecting::after {
            bottom: -10%;
            right: -10%;
            animation-delay: 0.1s;
        }

        @keyframes sparkleFloat {
            0% {
                transform: translate(0, 0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translate(0, -30px) scale(1.5);
                opacity: 0;
            }
        }

        .cell-gnome.exploding {
            background: #FF4500;
            animation: gnomeExplode 0.6s ease-in-out;
            position: relative;
        }

        .cell-gnome.exploding::before,
        .cell-gnome.exploding::after {
            content: '💥';
            position: absolute;
            font-size: 1.2em;
            animation: explosionDebris 0.6s ease-out forwards;
            pointer-events: none;
        }

        .cell-gnome.exploding::before {
            top: -20%;
            left: -20%;
            animation-delay: 0s;
        }

        .cell-gnome.exploding::after {
            bottom: -20%;
            right: -20%;
            animation-delay: 0.1s;
        }

        @keyframes explosionDebris {
            0% {
                transform: translate(0, 0) scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx, -20px), var(--ty, -20px)) scale(0.5) rotate(180deg);
                opacity: 0;
            }
        }

        .cell-gnome.dead {
            background: #696969;
            animation: none;
            transform: rotate(45deg);
        }

        @keyframes gnomeWalk {
            0% {
                transform: scale(1) rotate(-3deg);
                box-shadow: 0 0 20px rgba(144, 238, 144, 0.6);
            }
            100% {
                transform: scale(1.1) rotate(3deg);
                box-shadow: 0 0 30px rgba(144, 238, 144, 0.8);
            }
        }

        @keyframes gnomeCollect {
            0% {
                transform: scale(1) rotate(0deg);
                background: linear-gradient(135deg, #90EE90 0%, #66BB6A 100%);
                box-shadow: 0 0 20px rgba(144, 238, 144, 0.6);
            }
            50% {
                transform: scale(1.4) rotate(360deg);
                background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
                box-shadow: 0 0 40px rgba(255, 215, 0, 1);
            }
            100% {
                transform: scale(1) rotate(720deg);
                background: linear-gradient(135deg, #90EE90 0%, #66BB6A 100%);
                box-shadow: 0 0 20px rgba(144, 238, 144, 0.6);
            }
        }

        @keyframes gnomeExplode {
            0% {
                transform: scale(1);
                background: linear-gradient(135deg, #90EE90 0%, #66BB6A 100%);
                box-shadow: 0 0 10px rgba(144, 238, 144, 0.5);
            }
            25% {
                transform: scale(1.3) rotate(15deg);
                background: linear-gradient(135deg, #FF4500 0%, #FF6347 100%);
                box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
            }
            50% {
                transform: scale(1.6) rotate(-15deg);
                background: linear-gradient(135deg, #FF0000 0%, #8B0000 100%);
                box-shadow: 0 0 50px rgba(255, 0, 0, 1);
            }
            75% {
                transform: scale(1.3) rotate(10deg);
                background: linear-gradient(135deg, #FF4500 0%, #8B0000 100%);
                box-shadow: 0 0 30px rgba(139, 0, 0, 0.8);
            }
            100% {
                transform: scale(1);
                background: #696969;
                box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            }
        }

        @keyframes phoenixGlow {
            0% { box-shadow: 0 0 10px rgba(255, 107, 0, 0.6); }
            100% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.9); }
        }

        @keyframes invincibleShield {
            0% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
            100% { box-shadow: 0 0 25px rgba(255, 165, 0, 1); }
        }

        @keyframes rewindEffect {
            0% { transform: scale(1) rotate(0deg); background: #00d4ff; }
            50% { transform: scale(1.3) rotate(180deg); background: #0066ff; }
            100% { transform: scale(1) rotate(360deg); background: #90EE90; }
        }

        @keyframes bombExplode {
            0% {
                transform: scale(1);
                opacity: 1;
                box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            }
            50% {
                transform: scale(1.8);
                opacity: 1;
                box-shadow: 0 0 40px rgba(255, 0, 0, 1), 0 0 60px rgba(255, 69, 0, 0.8);
            }
            100% {
                transform: scale(2.5);
                opacity: 0;
                box-shadow: 0 0 80px rgba(255, 0, 0, 0.3);
            }
        }

        /* Cell reveal animation for fog of war */
        @keyframes cellReveal {
            0% {
                transform: scale(0.8);
                opacity: 0;
                filter: brightness(2);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                filter: brightness(1);
            }
        }

        .cell-revealed {
            animation: cellReveal 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }



        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #f5c6cb;
        }

        .game-message {
            font-size: 1.3em;
            font-weight: bold;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
            display: none;
            animation: messageSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        @keyframes messageSlideIn {
            0% {
                transform: translateY(-30px) scale(0.8);
                opacity: 0;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @media (max-width: 1024px) {
            .game-message {
                font-size: 1em;
                padding: 10px;
                margin-top: 10px;
            }
        }

        .game-message.win {
            background: linear-gradient(135deg, #d4edda 0%, #a8e6a1 100%);
            color: #155724;
            border: 2px solid #c3e6cb;
            animation: messageSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), victoryPulse 2s ease-in-out infinite;
            box-shadow: 0 5px 30px rgba(21, 87, 36, 0.3), 0 0 40px rgba(168, 230, 161, 0.5);
        }

        @keyframes victoryPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 5px 30px rgba(21, 87, 36, 0.3), 0 0 40px rgba(168, 230, 161, 0.5);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 8px 35px rgba(21, 87, 36, 0.4), 0 0 50px rgba(168, 230, 161, 0.7);
            }
        }

        .game-message.lose {
            background: linear-gradient(135deg, #f8d7da 0%, #f5a3a8 100%);
            color: #721c24;
            border: 2px solid #f5c6cb;
            animation: messageSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), defeatShake 0.5s ease-in-out;
            box-shadow: 0 5px 30px rgba(114, 28, 36, 0.3), 0 0 40px rgba(245, 163, 168, 0.5);
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @media (max-width: 768px) {
            .field-grid {
                max-width: 95vw;
                padding: 5px;
                gap: 1px;
            }
            
            .field-cell {
                font-size: 0.8em;
            }
        }

        @media (max-width: 768px) {
            .control-group {
                flex-direction: column;
                gap: 15px;
            }
            
            .field-container {
                flex-direction: column;
                align-items: center;
            }
            
            .field-display {
                min-width: unset;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>💣🌸🧙‍♂️ Interactive Gnome Adventure</h1>
            <p>Watch the gnome collect flowers and avoid bombs in this magical field!</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control-item">
                    <label for="fieldSize">Size</label>
                    <input type="number" id="fieldSize" min="3" max="20" value="8">
                </div>
                <div class="control-item">
                    <label for="numBombs">💣</label>
                    <input type="number" id="numBombs" min="0" max="100" value="6">
                </div>
                <div class="control-item">
                    <label for="numFlowers">🌸</label>
                    <input type="number" id="numFlowers" min="0" max="100" value="5">
                </div>
                <div class="control-item">
                    <label for="gameSpeed">Speed: <span id="speedValue">3x</span></label>
                    <input type="range" id="gameSpeed" min="1" max="5" value="3" oninput="updateSpeedLabel()">
                </div>
                <div class="control-item">
                    <label for="explorationAlgo">AI Style</label>
                    <select id="explorationAlgo" onchange="updateAlgorithm()">
                        <option value="wanderer" selected>Wanderer</option>
                        <option value="brave">Brave Explorer</option>
                        <option value="treasure-hunter">Treasure Hunter</option>
                        <option value="scaredy-cat">Scaredy Cat</option>
                        <option value="scout">Scout</option>
                        <option value="drifter">Drifter</option>
                    </select>
                </div>
            </div>
            <div class="button-group">
                <button class="btn btn-secondary" onclick="generateField()">Generate</button>
                <button class="btn btn-primary" onclick="startGame()" id="startButton">Start</button>
            </div>

            <div class="help-section">
                <div class="help-header" onclick="toggleHelp()">
                    <span id="help-toggle" class="collapsed">▼</span> Guide
                </div>
                <div class="help-content collapsed" id="helpContent">
                    <div class="help-grid">
                        <div class="help-item">
                            <span class="help-icon">🧙‍♂️</span>
                            <span class="help-text"><strong>Gnome</strong> - Your hero! Walks automatically</span>
                        </div>
                        <div class="help-item">
                            <span class="help-icon">💣</span>
                            <span class="help-text"><strong>Bomb</strong> - Damages gnome (-1 HP), triggers chain reactions</span>
                        </div>
                        <div class="help-item">
                            <span class="help-icon">🌸</span>
                            <span class="help-text"><strong>Regular Flower</strong> - Heals +1 HP (max 3)</span>
                        </div>
                        <div class="help-item">
                            <span class="help-icon">🌺</span>
                            <span class="help-text"><strong>Phoenix Flower</strong> - Heals +1 HP + 10s invincibility! (near 2+ bombs)</span>
                        </div>
                        <div class="help-item">
                            <span class="help-icon">👻</span>
                            <span class="help-text"><strong>Ghost Trail</strong> - Shows gnome's last 10 positions (fades with age)</span>
                        </div>
                        <div class="help-item">
                            <span class="help-icon">✨</span>
                            <span class="help-text"><strong>Invincible Gnome</strong> - Immune to bombs! From Phoenix Flower</span>
                        </div>
                        <div class="help-item">
                            <span class="help-icon">💀</span>
                            <span class="help-text"><strong>Dead</strong> - Game Over (0 HP)</span>
                        </div>
                    </div>
                    <div class="help-tips">
                        <strong>💡 Tips:</strong>
                        <ul>
                            <li>Chain reactions can trigger multiple bombs!</li>
                            <li>Collect all flowers to win</li>
                            <li>Adjust speed anytime during gameplay</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="results" id="results" style="display: none;">
            <div class="stats" id="stats"></div>
            <div class="field-container" id="fieldContainer"></div>
            <div class="game-message" id="gameMessage" style="display: none;"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="help-modal" id="helpModal">
        <div class="help-modal-content">
            <button class="help-modal-close" onclick="closeHelpModal()">×</button>
            <h2 style="margin-top: 0; margin-bottom: 20px; color: #495057;">🎮 Game Guide</h2>
            <div class="help-grid">
                <div class="help-item">
                    <span class="help-icon">🧙‍♂️</span>
                    <span class="help-text"><strong>Gnome</strong> - Your hero! Walks automatically</span>
                </div>
                <div class="help-item">
                    <span class="help-icon">💣</span>
                    <span class="help-text"><strong>Bomb</strong> - Damages gnome (-1 HP), triggers chain reactions</span>
                </div>
                <div class="help-item">
                    <span class="help-icon">🌸</span>
                    <span class="help-text"><strong>Regular Flower</strong> - Heals +1 HP (max 3)</span>
                </div>
                <div class="help-item">
                    <span class="help-icon">🌺</span>
                    <span class="help-text"><strong>Phoenix Flower</strong> - Heals +1 HP + 10s invincibility! (near 2+ bombs)</span>
                </div>
                <div class="help-item">
                    <span class="help-icon">👻</span>
                    <span class="help-text"><strong>Ghost Trail</strong> - Shows gnome's last 10 positions (fades with age)</span>
                </div>
                <div class="help-item">
                    <span class="help-icon">✨</span>
                    <span class="help-text"><strong>Invincible Gnome</strong> - Immune to bombs! From Phoenix Flower</span>
                </div>
                <div class="help-item">
                    <span class="help-icon">💀</span>
                    <span class="help-text"><strong>Dead</strong> - Game Over (0 HP)</span>
                </div>
            </div>
            <div class="help-tips">
                <strong>💡 Tips:</strong>
                <ul>
                    <li>Chain reactions can trigger multiple bombs!</li>
                    <li>Collect all flowers to win</li>
                    <li>Adjust speed anytime during gameplay</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Global variables for gnome
        let gnomePosition = { row: 0, col: 0 };
        let gnomeTimer = null;
        let currentField = null;
        let currentFieldSize = 0;
        let gnomeHealth = 3;
        let flowersCollected = 0;
        let gnomeStatus = 'happy'; // 'happy', 'collecting', 'exploding', 'dead', 'invincible'
        let stepCounter = 0; // Track how many steps gnome has taken

        // Feature 1: Ghost Trail
        let positionHistory = []; // Track last 10 positions with fading effect
        const MAX_HISTORY = 10;

        // Feature 2: Chain Reactions
        let chainReactionInProgress = false;
        let explodedBombs = new Set(); // Track which bombs have exploded

        // Feature 3: Flower Mutations
        let invincibilityTimer = null;
        let invincibilityTimeLeft = 0;

        // Exploration Algorithm Feature
        let explorationAlgorithm = 'wanderer'; // Current selected algorithm
        let visitedCells = new Set(); // Track "row,col" strings
        let knownBombs = new Set(); // Remember bomb locations as "row,col" strings
        let knownFlowers = new Set(); // Remember flower locations as "row,col" strings
        let lastMoveDirection = null; // For Drifter algorithm {row, col}

        // Minesweeper-style Fog of War
        let revealedCells = new Set(); // Track which cells have been revealed
        let cellBombCounts = new Map(); // Map "row,col" -> number of adjacent bombs

        // Bomb and flower field generation logic
        function createBombField(size, numBombs, numFlowers) {
            const totalItems = numBombs + numFlowers;
            if (totalItems > size * size) {
                throw new Error(`Total items (${totalItems}) cannot exceed field size (${size * size})`);
            }

            // Initialize empty field
            const field = Array(size).fill().map(() => Array(size).fill(0));

            // Create list of all possible positions
            const positions = [];
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    positions.push([i, j]);
                }
            }

            // Randomly select positions for bombs
            const bombPositions = [];
            for (let i = 0; i < numBombs; i++) {
                const randomIndex = Math.floor(Math.random() * positions.length);
                bombPositions.push(positions.splice(randomIndex, 1)[0]);
            }

            // Place bombs in selected positions
            bombPositions.forEach(([row, col]) => {
                field[row][col] = 1; // 1 = bomb
            });

            // Randomly select positions for flowers
            const flowerPositions = [];
            for (let i = 0; i < numFlowers; i++) {
                const randomIndex = Math.floor(Math.random() * positions.length);
                flowerPositions.push(positions.splice(randomIndex, 1)[0]);
            }

            // Place flowers in selected positions
            flowerPositions.forEach(([row, col]) => {
                field[row][col] = 2; // 2 = flower
            });

            // Feature 3: Mutate flowers based on bomb proximity
            mutateFlowers(field, size);

            // Place gnome at random position
            gnomePosition = {
                row: Math.floor(Math.random() * size),
                col: Math.floor(Math.random() * size)
            };

            return field;
        }

        // Count adjacent bombs for a cell
        function countAdjacentBombs(field, row, col, size) {
            let count = 0;
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            for (const [dr, dc] of neighbors) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                    if (field[newRow][newCol] === 1) {
                        count++;
                    }
                }
            }
            return count;
        }

        // Mutate flowers based on bomb proximity
        function mutateFlowers(field, size) {
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (field[i][j] === 2) { // Regular flower
                        const adjacentBombs = countAdjacentBombs(field, i, j, size);

                        if (adjacentBombs >= 2) {
                            // Phoenix Flower - dangerous location grants invincibility
                            field[i][j] = 4;
                        }
                        // All other flowers stay as regular flowers (2)
                    }
                }
            }
        }

        // Helper Functions for Exploration Algorithms

        // Reveal a cell and calculate its adjacent bomb count (Minesweeper-style)
        function revealCell(row, col) {
            const key = `${row},${col}`;

            // Mark as revealed
            revealedCells.add(key);

            // Calculate adjacent bomb count
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            let bombCount = 0;
            for (const [dr, dc] of neighbors) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < currentFieldSize &&
                    newCol >= 0 && newCol < currentFieldSize) {
                    if (currentField[newRow][newCol] === 1) {
                        bombCount++;
                    }
                }
            }

            // Store bomb count
            cellBombCounts.set(key, bombCount);

            // Update known bombs/flowers based on what's in THIS cell
            const content = currentField[row][col];
            if (content === 1) {
                knownBombs.add(key);
            } else if (content === 2 || content === 4) {
                knownFlowers.add(key);
            }
        }

        // Get what gnome can see in adjacent cells (Minesweeper fog of war)
        function getCellsInVision() {
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            return neighbors
                .map(([dr, dc]) => ({
                    row: gnomePosition.row + dr,
                    col: gnomePosition.col + dc
                }))
                .filter(({row, col}) =>
                    row >= 0 && row < currentFieldSize &&
                    col >= 0 && col < currentFieldSize
                )
                .map(({row, col}) => {
                    const key = `${row},${col}`;
                    const isRevealed = revealedCells.has(key);

                    return {
                        row,
                        col,
                        revealed: isRevealed,
                        content: isRevealed ? currentField[row][col] : null, // null = hidden
                        bombCount: isRevealed ? cellBombCounts.get(key) : null
                    };
                });
        }

        // Check if a position is adjacent to bombs (using vision + memory)
        function isAdjacentToBomb(row, col) {
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            for (const [dr, dc] of neighbors) {
                const newRow = row + dr;
                const newCol = col + dc;

                // Check if in bounds
                if (newRow >= 0 && newRow < currentFieldSize &&
                    newCol >= 0 && newCol < currentFieldSize) {

                    // Check visible bombs
                    if (currentField[newRow][newCol] === 1) {
                        return true;
                    }

                    // Check remembered bombs
                    if (knownBombs.has(`${newRow},${newCol}`)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Count bombs adjacent to a position (for danger scoring)
        function countAdjacentBombsAt(row, col) {
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            let count = 0;
            for (const [dr, dc] of neighbors) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < currentFieldSize &&
                    newCol >= 0 && newCol < currentFieldSize) {

                    // Check visible bombs
                    if (currentField[newRow][newCol] === 1) {
                        count++;
                    }
                    // Also check remembered bombs
                    else if (knownBombs.has(`${newRow},${newCol}`)) {
                        count++;
                    }
                }
            }
            return count;
        }

        // Update memory after each move (Minesweeper fog of war)
        function updateGnomeMemory() {
            // Mark current cell as visited
            const currentKey = `${gnomePosition.row},${gnomePosition.col}`;
            visitedCells.add(currentKey);

            // Reveal current cell if not already revealed
            if (!revealedCells.has(currentKey)) {
                revealCell(gnomePosition.row, gnomePosition.col);
            }

            // Note: Knowledge of bombs/flowers is now handled in revealCell()
            // Gnomes can only learn about cells they visit or have visited
        }

        // Find closest known flower using Manhattan distance
        function findClosestKnownFlower() {
            if (knownFlowers.size === 0) return null;

            let closest = null;
            let minDistance = Infinity;

            for (const flowerKey of knownFlowers) {
                const [row, col] = flowerKey.split(',').map(Number);
                const distance = Math.abs(gnomePosition.row - row) + Math.abs(gnomePosition.col - col);

                if (distance < minDistance) {
                    minDistance = distance;
                    closest = { row, col };
                }
            }

            return closest;
        }

        // Calculate Manhattan distance between two points
        function manhattanDistance(row1, col1, row2, col2) {
            return Math.abs(row1 - row2) + Math.abs(col1 - col2);
        }

        // Exploration Algorithm Functions

        // Wanderer: Pure random walk
        function algorithmWanderer(validMoves) {
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        // Brave Explorer: Prioritizes unexplored territory
        function algorithmBrave(validMoves) {
            // Filter for unexplored cells
            const unexploredMoves = validMoves.filter(move => {
                const destRow = gnomePosition.row + move.row;
                const destCol = gnomePosition.col + move.col;
                return !visitedCells.has(`${destRow},${destCol}`);
            });

            // If unexplored cells exist, pick random from them
            if (unexploredMoves.length > 0) {
                return unexploredMoves[Math.floor(Math.random() * unexploredMoves.length)];
            }

            // Otherwise, pick random from all valid moves
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        // Treasure Hunter: Greedy flower collection (fog of war)
        function algorithmTreasureHunter(validMoves) {
            // 1. Check known flowers in adjacent cells (from memory)
            for (const move of validMoves) {
                const destRow = gnomePosition.row + move.row;
                const destCol = gnomePosition.col + move.col;
                const key = `${destRow},${destCol}`;

                // If we know there's a flower here, go for it!
                if (knownFlowers.has(key)) {
                    return move;
                }
            }

            // 2. If known flowers exist, move toward nearest
            const closestFlower = findClosestKnownFlower();
            if (closestFlower) {
                // Pick move that minimizes distance to closest flower
                let bestMove = validMoves[0];
                let bestDistance = Infinity;

                for (const move of validMoves) {
                    const destRow = gnomePosition.row + move.row;
                    const destCol = gnomePosition.col + move.col;
                    const distance = manhattanDistance(destRow, destCol, closestFlower.row, closestFlower.col);

                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestMove = move;
                    }
                }

                return bestMove;
            }

            // 3. Otherwise, prefer unrevealed cells (explore for flowers!)
            const unrevealedMoves = validMoves.filter(move => {
                const destRow = gnomePosition.row + move.row;
                const destCol = gnomePosition.col + move.col;
                return !revealedCells.has(`${destRow},${destCol}`);
            });

            if (unrevealedMoves.length > 0) {
                return unrevealedMoves[Math.floor(Math.random() * unrevealedMoves.length)];
            }

            // 4. Fallback: random valid move
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        // Scaredy Cat: Risk-avoidant, survival-focused (fog of war)
        function algorithmScaredyCat(validMoves) {
            // If invincible, act brave
            if (gnomeStatus === 'invincible') {
                return algorithmBrave(validMoves);
            }

            // Calculate danger score for each move
            const scoredMoves = validMoves.map(move => {
                const destRow = gnomePosition.row + move.row;
                const destCol = gnomePosition.col + move.col;
                const key = `${destRow},${destCol}`;

                let danger = 0;

                // Check if we know there's a bomb here
                if (knownBombs.has(key)) {
                    danger += 100; // Known bomb = instant death
                }

                // If cell is revealed, use its bomb count
                if (revealedCells.has(key)) {
                    const bombCount = cellBombCounts.get(key) || 0;
                    danger += bombCount * 10;
                } else {
                    // Unrevealed cells have unknown risk
                    danger += 5; // Higher penalty for unknown
                }

                return { move, danger };
            });

            // Find minimum danger score
            const minDanger = Math.min(...scoredMoves.map(s => s.danger));

            // Get all moves with minimum danger
            const safestMoves = scoredMoves.filter(s => s.danger === minDanger);

            // Among safest, prefer revealed cells (known to be safe)
            const revealedSafe = safestMoves.filter(s => {
                const destRow = gnomePosition.row + s.move.row;
                const destCol = gnomePosition.col + s.move.col;
                return revealedCells.has(`${destRow},${destCol}`);
            });

            if (revealedSafe.length > 0) {
                return revealedSafe[Math.floor(Math.random() * revealedSafe.length)].move;
            }

            // Otherwise pick random from safest moves
            return safestMoves[Math.floor(Math.random() * safestMoves.length)].move;
        }

        // Scout: Balanced, intelligent decision-making (fog of war)
        function algorithmScout(validMoves) {
            const bombPenalty = (gnomeStatus === 'invincible') ? 0 : -30;

            const scoredMoves = validMoves.map(move => {
                const destRow = gnomePosition.row + move.row;
                const destCol = gnomePosition.col + move.col;
                const key = `${destRow},${destCol}`;

                let score = 0;

                // Check if we know there's a flower here
                if (knownFlowers.has(key)) {
                    score += 100; // Known flower = big win
                }

                // Move toward nearest known flower
                const closestFlower = findClosestKnownFlower();
                if (closestFlower) {
                    const currentDist = manhattanDistance(gnomePosition.row, gnomePosition.col, closestFlower.row, closestFlower.col);
                    const newDist = manhattanDistance(destRow, destCol, closestFlower.row, closestFlower.col);

                    if (newDist < currentDist) {
                        score += 20; // Moving closer to flower
                    } else if (newDist > currentDist) {
                        score -= 10; // Moving away from flower
                    }
                }

                // Unrevealed cells are valuable (exploration)
                if (!revealedCells.has(key)) {
                    score += 15;
                } else {
                    score -= 5; // Slightly discourage revisiting
                }

                // Bomb danger (from revealed cells)
                if (revealedCells.has(key)) {
                    const bombCount = cellBombCounts.get(key) || 0;
                    score += bombCount * bombPenalty;
                }

                // Known bombs are death
                if (knownBombs.has(key)) {
                    score -= 200;
                }

                // Add slight randomness for variety (±5%)
                score *= (0.95 + Math.random() * 0.1);

                return { move, score };
            });

            // Find maximum score
            const maxScore = Math.max(...scoredMoves.map(s => s.score));

            // Get all moves with maximum score
            const bestMoves = scoredMoves.filter(s => s.score === maxScore);

            // Pick random from best moves
            return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
        }

        // Drifter: Momentum-based wandering
        function algorithmDrifter(validMoves) {
            // 70% chance to continue in same direction if valid
            if (lastMoveDirection && Math.random() < 0.7) {
                const continueMove = validMoves.find(move =>
                    move.row === lastMoveDirection.row && move.col === lastMoveDirection.col
                );

                if (continueMove) {
                    return continueMove;
                }
            }

            // Otherwise pick random
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        function moveGnome() {
            if (!currentField || currentFieldSize === 0 || gnomeStatus === 'dead') return;

            // Feature 1: Track position history
            positionHistory.push({ row: gnomePosition.row, col: gnomePosition.col });
            if (positionHistory.length > MAX_HISTORY) {
                positionHistory.shift(); // Keep only last 10 positions
            }

            // Get possible moves (adjacent cells)
            const moves = [
                { row: -1, col: 0 },  // up
                { row: 1, col: 0 },   // down
                { row: 0, col: -1 },  // left
                { row: 0, col: 1 },   // right
                { row: -1, col: -1 }, // up-left
                { row: -1, col: 1 },  // up-right
                { row: 1, col: -1 },  // down-left
                { row: 1, col: 1 }    // down-right
            ];

            // Filter valid moves (within bounds)
            const validMoves = moves.filter(move => {
                const newRow = gnomePosition.row + move.row;
                const newCol = gnomePosition.col + move.col;
                return newRow >= 0 && newRow < currentFieldSize &&
                       newCol >= 0 && newCol < currentFieldSize;
            });

            // If no valid moves, stay in place
            if (validMoves.length === 0) return;

            // Select move using current algorithm
            let selectedMove;
            switch(explorationAlgorithm) {
                case 'wanderer':
                    selectedMove = algorithmWanderer(validMoves);
                    break;
                case 'brave':
                    selectedMove = algorithmBrave(validMoves);
                    break;
                case 'treasure-hunter':
                    selectedMove = algorithmTreasureHunter(validMoves);
                    break;
                case 'scaredy-cat':
                    selectedMove = algorithmScaredyCat(validMoves);
                    break;
                case 'scout':
                    selectedMove = algorithmScout(validMoves);
                    break;
                case 'drifter':
                    selectedMove = algorithmDrifter(validMoves);
                    break;
                default:
                    selectedMove = algorithmWanderer(validMoves);
            }

            // Apply the move
            gnomePosition.row += selectedMove.row;
            gnomePosition.col += selectedMove.col;

            // Store direction for Drifter algorithm
            lastMoveDirection = selectedMove;

            // Update memory
            updateGnomeMemory();

            // Increment step counter
            stepCounter++;

            // Handle interactions with what's under the gnome
            handleGnomeInteraction();

            // Update the visual field
            updateFieldDisplay();
        }

        function handleGnomeInteraction() {
            const cellContent = currentField[gnomePosition.row][gnomePosition.col];

            if (cellContent === 2 || cellContent === 4) { // Any type of flower
                gnomeStatus = 'collecting';
                flowersCollected++;

                // Heal the gnome (up to maximum of 3 health)
                if (gnomeHealth < 3) {
                    gnomeHealth++;
                }

                // Feature 3: Handle special flower types
                if (cellContent === 4) { // Phoenix Flower
                    activateInvincibility();
                }

                // Remove the flower from the field
                currentField[gnomePosition.row][gnomePosition.col] = 0;

                // Remove from memory
                knownFlowers.delete(`${gnomePosition.row},${gnomePosition.col}`);

                // Reset status after animation
                setTimeout(() => {
                    gnomeStatus = gnomeStatus === 'invincible' ? 'invincible' : 'happy';
                    updateFieldDisplay();

                    // Check if all flowers collected
                    const remainingFlowers = currentField.flat().filter(cell => cell === 2 || cell === 4).length;
                    if (remainingFlowers === 0) {
                        showGameMessage(`🌸 All flowers collected! The gnome survived ${stepCounter} steps!`, 'win');
                        stopGnomeMovement();
                    }
                }, 300);

            } else if (cellContent === 1) { // Bomb
                // Feature 3: Check invincibility
                if (gnomeStatus === 'invincible') {
                    // Invincible gnomes are protected!
                    return;
                }

                gnomeStatus = 'exploding';
                gnomeHealth--;

                // Feature 2: Trigger chain reaction
                const bombKey = `${gnomePosition.row},${gnomePosition.col}`;
                if (!explodedBombs.has(bombKey)) {
                    explodedBombs.add(bombKey);
                    triggerChainReaction(gnomePosition.row, gnomePosition.col);
                }

                if (gnomeHealth <= 0) {
                    // Gnome dies
                    setTimeout(() => {
                        gnomeStatus = 'dead';
                        positionHistory = []; // Clear ghost trail on death
                        updateFieldDisplay();
                        stopGnomeMovement();
                        showGameMessage(`💀 Game Over! The gnome survived ${stepCounter} steps before dying.`, 'lose');
                    }, 600);
                } else {
                    // Gnome survives but is hurt, respawn elsewhere
                    setTimeout(() => {
                        positionHistory = []; // Clear ghost trail on teleport/respawn
                        respawnGnome();
                        gnomeStatus = gnomeStatus === 'invincible' ? 'invincible' : 'happy';
                        updateFieldDisplay();
                    }, 600);
                }
            } else {
                gnomeStatus = gnomeStatus === 'invincible' ? 'invincible' : 'happy';
            }
        }

        // Feature 3: Activate invincibility from Phoenix Flower
        function activateInvincibility() {
            clearInterval(invincibilityTimer);
            invincibilityTimeLeft = 10; // 10 seconds of invincibility
            gnomeStatus = 'invincible';

            invincibilityTimer = setInterval(() => {
                invincibilityTimeLeft--;
                updateFieldDisplay();

                if (invincibilityTimeLeft <= 0) {
                    clearInterval(invincibilityTimer);
                    gnomeStatus = 'happy';
                    updateFieldDisplay();
                }
            }, 1000);
        }

        // Feature 2: Trigger chain reaction from bomb explosion
        function triggerChainReaction(row, col) {
            const neighbors = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            setTimeout(() => {
                for (const [dr, dc] of neighbors) {
                    const newRow = row + dr;
                    const newCol = col + dc;

                    if (newRow >= 0 && newRow < currentFieldSize &&
                        newCol >= 0 && newCol < currentFieldSize) {

                        const bombKey = `${newRow},${newCol}`;

                        if (currentField[newRow][newCol] === 1 && !explodedBombs.has(bombKey)) {
                            // Found an adjacent bomb - explode it!
                            explodedBombs.add(bombKey);

                            // Visual explosion effect
                            updateFieldDisplay();

                            // Damage gnome if they're at this position
                            if (gnomePosition.row === newRow && gnomePosition.col === newCol) {
                                if (gnomeStatus !== 'invincible') {
                                    gnomeHealth--;
                                    gnomeStatus = 'exploding';
                                    if (gnomeHealth <= 0) {
                                        setTimeout(() => {
                                            gnomeStatus = 'dead';
                                            positionHistory = []; // Clear ghost trail on death
                                            updateFieldDisplay();
                                            stopGnomeMovement();
                                            showGameMessage(`💀 Game Over! Chain reaction after ${stepCounter} steps!`, 'lose');
                                        }, 400);
                                    }
                                }
                            }

                            // Continue chain reaction
                            triggerChainReaction(newRow, newCol);
                        }
                    }
                }
            }, 200); // Delay for cascading effect
        }

        function showGameMessage(message, type) {
            const messageElement = document.getElementById('gameMessage');
            if (!messageElement) {
                // Create message element if it doesn't exist
                const newMessage = document.createElement('div');
                newMessage.id = 'gameMessage';
                newMessage.className = `game-message ${type}`;
                newMessage.textContent = message;
                document.querySelector('.results').appendChild(newMessage);
            } else {
                messageElement.className = `game-message ${type}`;
                messageElement.textContent = message;
                messageElement.style.display = 'block';
            }
        }

        function respawnGnome() {
            // Find a safe spot to respawn (not on a bomb)
            let attempts = 0;
            do {
                gnomePosition.row = Math.floor(Math.random() * currentFieldSize);
                gnomePosition.col = Math.floor(Math.random() * currentFieldSize);
                attempts++;
            } while (currentField[gnomePosition.row][gnomePosition.col] === 1 && attempts < 100);
        }

        function updateFieldDisplay() {
            const fieldContainer = document.getElementById('fieldContainer');
            if (!fieldContainer || !currentField) return;

            // Re-render the field with the new gnome position
            fieldContainer.innerHTML = '';
            const fieldDisplay = renderField(currentField, 'Bomb & Flower Field');
            fieldContainer.appendChild(fieldDisplay);

            // Update stats to show current gnome status
            const bombCount = currentField.flat().filter(cell => cell === 1).length;
            // Count all flower types: regular (2), phoenix (4)
            const flowerCount = currentField.flat().filter(cell => cell === 2 || cell === 4).length;
            showStats(currentFieldSize, bombCount, flowerCount);
        }

        function getSpeedInterval() {
            const speed = parseInt(document.getElementById('gameSpeed').value);
            // Speed 1 = 1600ms (Very Slow), Speed 3 = 800ms (Normal), Speed 5 = 200ms (Very Fast)
            const intervals = {
                1: 1600,  // Very Slow
                2: 1200,  // Slow
                3: 800,   // Normal
                4: 400,   // Fast
                5: 200    // Very Fast
            };
            return intervals[speed] || 800;
        }

        function updateSpeedLabel() {
            const speed = parseInt(document.getElementById('gameSpeed').value);
            const labels = {
                1: '1x',
                2: '2x',
                3: '3x',
                4: '4x',
                5: '5x'
            };
            document.getElementById('speedValue').textContent = labels[speed] || '3x';

            // If game is running, restart with new speed
            if (gnomeTimer) {
                startGnomeMovement();
            }
        }

        function updateAlgorithm() {
            explorationAlgorithm = document.getElementById('explorationAlgo').value;
            // No need to restart - will take effect on next move
        }

        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            modal.classList.add('active');
        }

        function closeHelpModal() {
            const modal = document.getElementById('helpModal');
            modal.classList.remove('active');
        }

        // Close modal when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('helpModal');
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeHelpModal();
                }
            });
        });

        function startGnomeMovement() {
            clearInterval(gnomeTimer);
            const interval = getSpeedInterval();
            gnomeTimer = setInterval(moveGnome, interval);
        }

        function stopGnomeMovement() {
            clearInterval(gnomeTimer);
            gnomeTimer = null;
        }

        // Get Minesweeper-style color for bomb counts
        function getBombCountColor(count) {
            const colors = {
                1: '#0000FF', // Blue
                2: '#008000', // Green
                3: '#FF0000', // Red
                4: '#000080', // Dark Blue
                5: '#800000', // Maroon
                6: '#008080', // Teal
                7: '#000000', // Black
                8: '#808080'  // Gray
            };
            return colors[count] || '#000000';
        }

        function renderField(field, title) {
            const size = field.length;

            const fieldDisplay = document.createElement('div');
            fieldDisplay.className = 'field-display';

            const fieldTitle = document.createElement('div');
            fieldTitle.className = 'field-title';
            fieldTitle.textContent = title;
            fieldDisplay.appendChild(fieldTitle);

            const fieldGrid = document.createElement('div');
            fieldGrid.className = 'field-grid';
            fieldGrid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            fieldGrid.style.width = `min(90vw, ${size * 40}px)`;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'field-cell';

                    // Feature 1: Check if this is part of ghost trail and calculate opacity
                    let ghostTrailIndex = -1;
                    for (let idx = 0; idx < positionHistory.length; idx++) {
                        if (positionHistory[idx].row === i && positionHistory[idx].col === j) {
                            ghostTrailIndex = idx;
                            break;
                        }
                    }

                    const cellKey = `${i},${j}`;
                    const isRevealed = revealedCells.has(cellKey);

                    // Check if gnome is at this position
                    if (gnomePosition.row === i && gnomePosition.col === j) {
                        cell.className += ` cell-gnome ${gnomeStatus}`;
                        if (gnomeStatus === 'dead') {
                            cell.textContent = '💀';
                        } else if (gnomeStatus === 'exploding') {
                            cell.textContent = '💥';
                        } else if (gnomeStatus === 'collecting') {
                            cell.textContent = '🌟';
                        } else if (gnomeStatus === 'invincible') {
                            cell.textContent = '✨🧙‍♂️✨';
                        } else {
                            cell.textContent = '🧙‍♂️';
                        }
                    } else if (ghostTrailIndex >= 0 && gnomeStatus !== 'dead') {
                        // Feature 1: Show ghost trail with fading opacity
                        // Older positions (lower index) are more transparent
                        const opacity = (ghostTrailIndex + 1) / positionHistory.length;
                        cell.className += ' cell-ghost-trail';
                        cell.style.opacity = opacity * 0.5; // Max 0.5 opacity for newest trail
                    } else if (!isRevealed) {
                        // FOG OF WAR: Unrevealed cells are hidden
                        cell.className += ' cell-hidden';
                        cell.textContent = '?';
                    } else if (field[i][j] === 1) {
                        // Revealed bomb
                        cell.className += ' cell-bomb';
                        cell.textContent = '💣';
                    } else if (field[i][j] === 2) {
                        // Revealed regular flower
                        cell.className += ' cell-flower';
                        cell.textContent = '🌸';
                    } else if (field[i][j] === 4) {
                        // Revealed phoenix flower
                        cell.className += ' cell-phoenix-flower';
                        cell.textContent = '🌺';
                    } else {
                        // Revealed empty cell - show bomb count
                        cell.className += ' cell-empty';
                        const bombCount = cellBombCounts.get(cellKey) || 0;
                        if (bombCount > 0) {
                            cell.textContent = bombCount.toString();
                            cell.style.color = getBombCountColor(bombCount);
                            cell.style.fontWeight = 'bold';
                        } else {
                            cell.textContent = '';
                        }
                    }

                    fieldGrid.appendChild(cell);
                }
            }

            fieldDisplay.appendChild(fieldGrid);
            return fieldDisplay;
        }

        function showStats(size, numBombs, numFlowers) {
            const totalCells = size * size;
            const totalItems = numBombs + numFlowers;
            const density = ((totalItems / totalCells) * 100).toFixed(1);

            const invincibilityDisplay = invincibilityTimeLeft > 0 ?
                `<span style="color: #FFD700;">✨ ${invincibilityTimeLeft}s</span>` :
                '<span style="color: #999;">-</span>';

            const statsHTML = `
                <div class="stat-item">
                    <div class="stat-value">${size}×${size}</div>
                    <div class="stat-label">Field Size</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">💣 ${numBombs}</div>
                    <div class="stat-label">Bombs</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">🌸 ${numFlowers}</div>
                    <div class="stat-label">Flowers</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">❤️ ${gnomeHealth}</div>
                    <div class="stat-label">Gnome Health</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">👣 ${stepCounter}</div>
                    <div class="stat-label">Steps</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">🏆 ${flowersCollected}</div>
                    <div class="stat-label">Flowers Used</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${invincibilityDisplay}</div>
                    <div class="stat-label">Invincibility</div>
                </div>
            `;

            document.getElementById('stats').innerHTML = statsHTML;
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            const results = document.getElementById('results');
            results.style.display = 'block';
            results.innerHTML = '';
            results.appendChild(errorDiv);
        }

        function generateField() {
            const size = parseInt(document.getElementById('fieldSize').value);
            const numBombs = parseInt(document.getElementById('numBombs').value);
            const numFlowers = parseInt(document.getElementById('numFlowers').value);

            // Validation
            if (size < 3 || size > 20) {
                showError('Field size must be between 3 and 20');
                return;
            }

            if (numBombs < 0 || numFlowers < 0) {
                showError('Number of bombs and flowers must be non-negative');
                return;
            }

            if (numBombs + numFlowers > size * size) {
                showError(`Total items (${numBombs + numFlowers}) cannot exceed field size (${size * size})`);
                return;
            }

            try {
                const bombField = createBombField(size, numBombs, numFlowers);

                // Reset gnome stats for new game
                gnomeHealth = 3;
                flowersCollected = 0;
                gnomeStatus = 'happy';
                stepCounter = 0;

                // Reset new feature states
                positionHistory = [];
                chainReactionInProgress = false;
                explodedBombs = new Set();
                invincibilityTimeLeft = 0;
                clearInterval(invincibilityTimer);
                invincibilityTimer = null;

                // Reset algorithm memory
                visitedCells = new Set();
                knownBombs = new Set();
                knownFlowers = new Set();
                lastMoveDirection = null;

                // Reset fog of war
                revealedCells = new Set();
                cellBombCounts = new Map();

                // Store current field for gnome movement
                currentField = bombField;
                currentFieldSize = size;

                // Initialize memory with starting position
                visitedCells.add(`${gnomePosition.row},${gnomePosition.col}`);
                updateGnomeMemory(); // This will reveal the starting cell
                
                const results = document.getElementById('results');
                results.style.display = 'block';
                
                // Hide any previous game messages
                const gameMessage = document.getElementById('gameMessage');
                if (gameMessage) {
                    gameMessage.style.display = 'none';
                }
                
                showStats(size, numBombs, numFlowers);
                
                const fieldContainer = document.getElementById('fieldContainer');
                fieldContainer.innerHTML = '';
                
                // Show bomb & flower field
                const bombFieldDisplay = renderField(bombField, 'Bomb & Flower Field');
                fieldContainer.appendChild(bombFieldDisplay);

                // Stop any existing gnome movement
                stopGnomeMovement();

            } catch (error) {
                showError(error.message);
            }
        }

        function startGame() {
            if (!currentField) {
                showError('Please generate a field first!');
                return;
            }

            // Start gnome movement
            startGnomeMovement();
        }

        // Initialize with default field on page load
        document.addEventListener('DOMContentLoaded', function() {
            generateField();
        });

        // Allow Enter key to generate field
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                generateField();
            }
        });
    </script>
</body>
</html> 